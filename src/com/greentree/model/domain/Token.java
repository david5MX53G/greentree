package com.greentree.model.domain;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Date;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

import org.apache.commons.codec.binary.Base64;

import com.greentree.model.exception.TokenException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * <code>Token</code> objects are used to validate <code>{@link Claim}</code>
 * objects, which grant access to data contained in <code>{@link Block}</code>
 * objects. Much of the code for this class comes from marilena.panagiotidou and
 * is available here: <a href="https://www.mkyong.com/java/
 * java-asymmetric-cryptography-example/">Java â€“ Asymmetric Cryptography
 * example</a>.
 *
 * @author david5MX53G
 */
public class Token implements Serializable {
    /** 
     * {@link org.apache.logging.log4j.Logger} is for logging logs to the log
     */
    Logger logger = LogManager.getLogger();

    /**
     * generated by Eclipse ID for implementing
     * <code>{@link Serializable}</code>.
     */
    private static final long serialVersionUID = -6888536819846215415L;

    /**
     * used for getting the <code>{@link RSAPublicKey}</code> and
     * <code>{@link RSAPrivateKey}</code>
     *
     * TODO: make these private!
     */
    RSAPublicKey publicKey;
    RSAPrivateKey privateKey;

    /**
     * used to validate ownership of a <code>Token</code> object
     */
    private String passphrase;

    /**
     * contains a list of all <code>{@link Block}</code> objects issued by this
     */
    private ArrayList<Block> blockChain = new ArrayList<>();

    /**
     * Creates a new <code>Token</code> instance with a 2048-bit RSA
     * <code>{@link KeyPair}</code>, secret <code>passphrase</code> with which
     * to validate users, and <code>{@link Cipher}</code> to decrypt ciphertext
     * sent to this object via <code>{@link PublicKey}</code> cryptography.
     *
     * @param passphrase keep it secret; keep it safe
     * @throws TokenException when something goes wrong during constructions
     */
    public Token(String passphrase) throws TokenException {
        this.passphrase = passphrase;
        KeyPairGenerator keyGen;
        try {
            keyGen = KeyPairGenerator.getInstance("RSA");
        } catch (NoSuchAlgorithmException e) {
            String msg = "NoSuchAlgorithmException thrown by KeyPairGenerator: " + e.getMessage();
            throw new TokenException(msg, new Exception());
        }
        keyGen.initialize(2048);
        KeyPair pair = keyGen.genKeyPair();
        this.privateKey = (RSAPrivateKey) pair.getPrivate();
        this.publicKey = (RSAPublicKey) pair.getPublic();
        this.blockChain.add(Block.ROOT);
        this.addBlock("token instantiated at " + new Date().toString(),
            this.encrypt(this.passphrase));
    }

    /**
     * Creates a bogus <code>{@link Token}</code> object that will not validate.
     */
    public Token() {

    }

    /**
     * @return <code>{@link ArrayList}</code> of <code>{@link Block}</code>
     * objects issued by this
     */
    public ArrayList<Block> getBlockChain() {
        return this.blockChain;
    }

    /**
     * Adds a new {@link Block} to the <code>{@link Token#blockChain}</code>.
     *
     * @param msg {@link String} to be stored in a new
     * <code>{@link Block}</code> in the <code>
     *     blockChain</code> of this {@link Token}
     * @param pass {@link String} should be encrypted with the
     * {@link RSAPublicKey} of this <code>
     *     Token</code> and return true from {@link Token#checkPassphrase(String)}
     */
    public void addBlock(String msg, String pass) {
        if (this.checkPassphrase(pass)) {
            this.blockChain.add(
                new Block(msg, this.blockChain.get(this.blockChain.size() - 1), this)
            );
        }
    }

    /**
     * Returns the <code>PublicKey</code> of the <code>Token</code>. This is
     * used to send securely encrypted <code>String</code> objects back to the
     * <code>Token</code> for validation against the <code>Token</code>
     * passphrase.
     *
     * @return RSAPublicKey used for sending encrypted messages which only this
     * object can decrypt
     */
    public RSAPublicKey getPublicKey() {
        return this.publicKey;
    }

    /**
     * Returns the input encrypted by this <code>{@link Token#publicKey}</code>.
     *
     * @param plaintext to be encrypted with the <code>RSAPublicKey</code> of
     * this <code>Token
     * </code>
     * @return input encrypted by this <code>{@link Token#publicKey}</code>
     * @throws TokenException when encryption fails
     */
    public String encrypt(String plaintext) throws TokenException {
        Cipher cipher;
        String ciphertext = null;
        try {
            cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, this.getPublicKey());
            ciphertext = Base64.encodeBase64String(cipher.doFinal(plaintext.getBytes("UTF-8")));
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException
            | IllegalBlockSizeException | BadPaddingException
            | UnsupportedEncodingException e) {
            String msg = e.getClass().getName() + " TokenException: " + e.getMessage();
            throw new TokenException(msg, new Exception());
        }
        return ciphertext;
    }

    /**
     * Confirms whether the given <code>{@link Token}</code> has the same value
     * as this. The method should only return true if both variables refer to
     * the same object because each <code>Token
     * </code> is initialized with a unique <code>{@link KeyPair}</code>.
     *
     * @param other will be compared with this <code>Token</code> based on the
     * Base64-encoded <code>{@link RSAPublicKey}</code> values of each
     * @return true when the given <code>Token</code> has the same value as this
     * <code>Token</code>
     */
    public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Token) {
            Token that = (Token) other;
            if (Base64.encodeBase64String(this.getPublicKey().getEncoded()).equals(Base64.encodeBase64String(that.getPublicKey().getEncoded()))) {
                result = true;
            }
        }
        return result;
    }

    @Override
    public int hashCode() {
        return this.getPublicKey().getModulus().hashCode();
    }

    @Override
    public String toString() {
        String blocks = String.valueOf(this.blockChain.size());
        Integer pass = this.passphrase.length();
        String publicKey = this.publicKey.toString();
        String privateKey = this.privateKey.toString();

        return "blocks: " + blocks + "\n"
            + "passphrase: " + pass + "\n"
            + "publicKey: " + publicKey + "\n"
            + "privateKey: " + privateKey + "\n";
    }

    /**
     * Decrypts the given ciphertext <code>String</code> using the private key
     * of the object, then checks the resulting plaintext against the passphrase
     * and returns true or false.
     *
     * @param ciphertext to be decrypted
     * @return true, if ciphertext matches the passphrase of this
     * <code>{@link Token}</code>
     * @throws InvalidKeyException
     * @throws UnsupportedEncodingException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    public Boolean checkPassphrase(String ciphertext) {
        try {
            Cipher cipher;
            String plaintext = null;
            try {
                cipher = Cipher.getInstance("RSA");
                cipher.init(Cipher.DECRYPT_MODE, this.privateKey);
                plaintext = new String(cipher.doFinal(Base64.decodeBase64(ciphertext)), "UTF-8");
            } catch (NoSuchAlgorithmException e) {
                logger.debug(
                    "NoSuchAlgorithmException on getting RSA cipher instance: " + e.getMessage()
                );
            } catch (NoSuchPaddingException e) {
                logger.debug(
                    "NoSuchPaddingException on getting RSA cipher instance: " + e.getMessage()
                );
            }

            if (plaintext.equals(this.passphrase)) {
                return true;
            } else {
                return false;
            }
        } catch (InvalidKeyException | UnsupportedEncodingException
            | IllegalBlockSizeException | BadPaddingException e) {
            logger.debug(e.getMessage());
            return false;
        }
    }

    /**
     * Encrypts the passphrase using the public key of the <code>Token</code>,
     * decrypts the <code>
     * Token</code> with the corresponding private key, and returns true, if the
     * decrypted text matches the passphrase. This simulates the process of a
     * <code>User</code> sending the encrypted passphrase to the
     * <code>Token</code> for validation, ensuring the <code>Token
     * </code> is in good working order.
     *
     * @return True if the <code>Token</code> is able to encrypt and decrypt its
     * passphrase
     * @throws BadPaddingException when this fails RSA cipher testing
     * @throws NoSuchPaddingException when this fails RSA cipher testing
     * @throws NoSuchAlgorithmException when this fails RSA cipher testing
     * @throws InvalidKeyException when this fails RSA cipher testing
     * @throws UnsupportedEncodingException when this fails RSA cipher testing
     * @throws IllegalBlockSizeException when this fails RSA cipher testing
     * @throws TokenException when cipher validation throws an
     * <code>{@link Exception}</code>
     */
    public boolean validate() throws TokenException {
        if (this.publicKey == null | this.privateKey == null | this.passphrase == null
            | this.blockChain == null) {
            return false;
        }

        if (this.checkPassphrase(this.encrypt(this.passphrase))) {
            return true;
        } else {
            logger.debug("Passphrase encryption, decryption or match failed.");
            return false;
        }
    }

    /**
     * adds a <code>Block</code> to this {@link Token#blockChain}, granting
     * access to some other <code>Token</code> per the given <code>Claim</code>.
     *
     * @param data {@link String} stored in the new {@link Block} and accessible
     * only to the given
     * <cide>claim</code>
     * @param ciphertext {@link String} encrypted with the
     * {@link Token#publicKey} of this object
     * @param claim {@link Claim} specifying some other {@link Token} that is
     * allowed read access on the new <code>Block</code>
     */
    public void addBlock(String data, String ciphertext, Claim claim) {
        if (this.checkPassphrase(ciphertext)) {
            Block block = new Block(data, this.blockChain.get(this.blockChain.size() - 1), this);
            block.addClaim(claim, ciphertext);
            this.blockChain.add(block);
        }
    }
}
